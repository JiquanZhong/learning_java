# JVM

## 内存结构

JDK1.7

![Java 运行时数据区域（JDK1.7）](https://camo.githubusercontent.com/4025b8088092fb8317e35063d1807f0bbdbc64d6a165a0d35fe18c8a7e569a55/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f6a6176612d72756e74696d652d646174612d61726561732d6a646b312e372e706e67)

JDK1.8：

![Java 运行时数据区域（JDK1.8 ）](https://camo.githubusercontent.com/fe814cf05191ee80fe59aec231044ade5611c082d71c09403d7598d6c57fee52/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f6a6176612d72756e74696d652d646174612d61726561732d6a646b312e382e706e67)

线程私有：程序计数器，虚拟机栈和本地方法栈

线程共享：方法区和堆

注意：方法区是JVM规范中定义的名字，在HotSpot中，具体的实现为永久代（JDK1.7）和元空间（JDK1.8）



### 程序计数器

线程私有的，比较小的 一块内存区域，存储着线程下一条指令的虚拟地址。当线程来换切换的时候，程序计数器可以告知程序目前的执行位置。

注意：唯一不会出现OOM的区域



### 虚拟机栈

线程私有的内存区域，用于存放java方法的调用。每一次java方法的调用都会有一个对应的栈帧被压入栈，方法调用结束则出栈。

栈由一个个栈帧组成，一个栈帧包含：局部变量表，操作数栈，动态链接和返回地址。



#### 局部变量表

存放方法所需要的各种变量包括基本数据类型的变量和对象引用变量。

注意：对象引用变量存放的可能是堆内的对象地址，也可能是代表对象的句柄

#### 操作数栈

充当方法调用的中转站，用于存放方法内计算的结果。同时临时的计算结果也会被放在这里。

#### 动态链接

服务于一个方法调用另一个方法的场景。编译后，栈帧的动态链接存放的是其他方法的符号引用。而在类加载期间，符号引用就会被替换成方法区中运行常量池的直接引用。（此过程也被称之为动态连接）

虚拟机栈会报的两种异常：

* StackOverFlowError : 当栈大小超过设定的最大栈大小，且无法动态扩容的情况下报出此错误
* OutOfMemoryError : 当栈大小可以动态扩容，但是申请不到足够内存的情况报出此错误



### 本地方法栈

和虚拟机栈类似，但只存放本地方法的栈帧

### 堆

用于存放对象实例以及数组，JDK1.7后把字符串常量池也放在堆中，是JVM中最大的一块区域，也是GC回收的主要区域。

但随着JIT和逃逸分析技术的成熟，栈上分配和标量替换等优化技术会使得一些对象不分配在堆上，而在栈上直接分配内存。

**逃逸分析**：如果方法中的对象没有被外界引用或者被返回，则认为没有逃逸，可以在栈上分配对象空间

**栈上分配**：如果逃逸分析该对象没有逃逸，则可把对象在栈上进行内存分配，对象占用的内存随着方法的调用而被回收

**标量替换**：如果对象信息可以直接使用基本类型数据进行替换，那么就不会创建对象，而是在局部变量表中存储对象的信息



#### 堆的组成

堆可以分为三个部分：新生代，老生代和永久代（永久代在物理上属于堆空间，而在逻辑上属于方法区，1.8后永久代分去了元空间）



#### 新生代

新生代又分为：Eden和两个Survivor区

初始创建的对象会被划分在Eden区，在经历一次GC没被回收后会被放入Survivor区。Survivor中的对象每经历一次GC年龄加1，到达最大年龄15次后会被放入老年代。

为什么15？

因为对象头用于记录对象年龄的区域为4位，可以记录的最大值为2^4-1=15。可以设置该值，但不可以超过15。

新生代的对象存活率较低，所以使用复制算法，避免GC后产生大量的内存碎片。



#### 字符串常量池

字符串常量池是专门针对String类设计的一块区域，为了避免字符串的重复创建。在1.7后从方法区放入了堆中（静态变量也是）。

其本质上是一个哈希表，键为字符串的字面量，值为String对象在堆中的引用。

因为永久代中的GC回收效率太低，只有fullGC的时候才会回收，所以1.7把字符串常量池放入在堆内存中。



### 方法区

当JVM需要使用一个类的时候，需要加载并解析class文件获取相关信息，再把信息存放在方法区。所以方法区中存放着的信息有：类信息，字段信息，方法信息，常量，静态变量，JIT编译后的代码缓存等数据。

方法区是JVM规范中提出的概念，而永久代是1.7之前HotSpot的具体方法区的实现，元空间是1.8后的具体实现。元空间使用的是本地内存，由操作系统负责内存的分配和回收。

为什么后面变成了元空间？

1. 方法区的大小很难确定。在许多框架中会动态加载需要的类，一旦方法区中的内存不足，会报OOM，而在程序运行前是很难正确预测出元空间所需使用的内存大小。
2. 方法区中的对象很难被回收。只有fullGC才能回收方法区中的内存，而fullGC的性能消耗很大，STW降低系统的吞吐量。长时间不fullGC会造成内存的浪费。
3. 回收效率不高。方法区中的大部分对象都不需要被回收，而触发fullGC的代价太大。性价比不高。

![堆内存结构](https://camo.githubusercontent.com/6562e89d99ec8b3c1f1d553f602aaa47845b557f4f0f34e691bd767819d2b158/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f686f7473706f742d686561702d7374727563747572652e706e67)

#### 运行时常量池

是方法区的组成之一，存放着编译器生成的字面量和符号引用。

java文件编译后的class文件中也会有个常量池，存放着该类所需要的常量。而在该class文件被加载进内存后，这些class文件的常量池会被合并在运行时常量池中，不同的类可以共用同一个常量。（解析阶段会把符号引用转化为直接引用）



### 创建一个对象的过程

1. **加载类**：JVM先检查类是否被加载。如果对象对应的类以及加载在了方法区，则不需要加载类，否则进入类的加载流程

2. **分配内存**：对象的大小在类被加载后就可以确定下来，此时需要在堆为对象分配对应大小的内存。具体的内存分配方式有两种策略：

   1. **指针碰撞**：在内存规整的情况下，使用一个边界指针记录可用内存的开头。为对象分配一定的内存后指针往后移动对应的大小长度。

   2. **空闲列表**：在内存不规则的情况下，JVM会维护一个列表，用于记录堆中还未使用的内存位置。

      使用哪一种策略取决于垃圾回收算法，标记清除会产生较多的内存碎片，适合用空闲列表。而复制和标记整理算法的内存空间规整，适合用指针碰撞。

   对象的内存分配过程比较频繁，多个线程同时创建对象，在分配内存的时候也会有内存分配的并发问题，一般来讲有两种策略解决此问题：

   1. **CAS+失败重试**：CAS是乐观锁的具体实现。如果失败则不断重试直到成功为止
   2. **TLAB**：TLAB是线程在堆中独占的一块区域。JVM为每个线程都在Eden区中分配了一块独享的区域，以避免内存分配时的并发问题。但在线程的TLAB空间不足的情况下会使用上一个策略

3. **初始化零值**：把分配好的内存空间都赋0值，保证对象此时的实例字段可以被使用。

4. **设置对象头**：对对象头的信息进行设置，比如：锁信息，类信息，哈希码，gc年龄等

5. **执行<init>方法**：直到上一步骤，JVM层面的初始化工作以及全部完成，开始java层面的初始化工作，如构造方法，构造代码块。

### 对象的访问定位

程序通过栈上的reference来操作堆上的具体数据，而对象的访问方式有两种：句柄访问和直接指针。

**句柄访问**

句柄池在堆内存中，存放着两个指针，一个指向方法区的类，另一个指向堆中的实例。而栈帧中的局部变量表存放的是对象在句柄池的地址。

使用场景：一般配合着GC算法使用。比如在复制和标记整理算法中涉及到对象的频繁移动，导致对象的地址会不停地改变。如果使用句柄访问，则GC后只需要更改句柄池中的对象地址即可，不需要通知线程修改reference的值。

**直接指针**

线程中存放的就是对象在堆中的地址。并且对象中还保存着指向类的指针。

##  垃圾回收

### 内存分配和回收规则

* 对象优先在Eden区分配

  所有创建的对象优先在新生代的Eden区分配内存，如果Eden区没有足够的内存，则会发动一次Minor GC，如果GC期间在Eden区的对象过大无法放入Survivor，那么会通过分配担保机制放入老年代。GC后，新对象会优先考虑被放入Eden

* 大对象直接进入老年代

  如果一个对象需要大量连续的空间，那么会被直接放入老年代。阈值由虚拟机动态决定，或者自己可以设置

* 长期存活的对象放入老年代

  当对象的GC年龄超过15（默认值）就会被转入老年代。GC年龄在Minor GC中每次都会增长1

### GC的分类

大体上可以把JVM中的GC分为两类：

* Partial GC：收集部分堆
  1. Young GC，只收集新生代的GC
  2. Old GC，只收集老年代的GC
  3. Mixed GC，收集整个新生代以及部分老年代的GC
* Full GC：收集整个堆，包括永久代（如果存在的话）



### 判断对象是否应该被回收的算法

1. 引用计数法：每当被引用，计数器就加1，为0表示该对象不再被使用，即可以被回收。但这种方法解决不了循环引用的问题。

2. 可达性分析：从一系列肯定不能被回收的对象开始（GC root），往下搜索引用链并标记。最后没被标记的对象即为不再被使用的对象，可以被回收。这种方法被JVM使用。

   GC Root：

   * 虚拟机栈和本地方法栈中使用的对象
   * 方法区中常量和静态变量使用的对象
   * 被同步锁持有的对象
   * JNI引用的对象

对象被标记可回收后也并不一定会被马上回收，会被先放入一个回收队列中，如果在下一次GC前被引用则可继续存活。但这种方式只能缓刑一次，第二次会被马上回收。



### 引用类型

Java中提供了四种引用类型，与GC配合：强引用，软引用，弱引用和虚引用

1. 强引用：大部分的引用都是强引用，即变量赋值的方式。在这种引用下的对象绝对不会被回收，哪怕报出OOM。
2. 软引用：在报出OOM前会回收该类型引用。一般用于实现内存敏感的高速缓存
3. 弱引用：弱引用的对象一旦被发现就会被回收。
4. 虚引用：不决定对象的生命周期，形同虚设。和引用队列配合使用，可以在回收前发送一些通知。



### 类的回收

判断方法区中的类是否应该被回收的条件比较苛刻：

1. 该类的实例都被回收
2. 类的卸载器被回收
3. 类对象没有被引用，即没有地方通过反射访问该类的方法

满足上述条件，类也不一定会被回收。



### 垃圾收集算法

#### 标记清除算法

标记出被引用过的对象，最后把没被标记的对象都回收。

两个问题：

空间上会有大量的内存碎片

时间上，标记和清除这两个操作效率都不高

适用于老年代，不适用于新生代，因为新生代的对象存活率低，产生大量的内存碎片

#### 复制算法

把内存分为两块均等的区域，每次只使用其中一块。当其中一块用完后就会进行GC，把还存活的对象复制在另一块中，然后清空这块内存。

两个问题：

不适用于老年代，因为移动大量对象的消耗很大

浪费了一般的空间

适用于新生代

#### 标记整理算法

前面标记的步骤与标记清除一样，后续整理步骤为，把 所有存活的对象移向内存的一端然后清理掉边界外的内存区域。

由于多了整理这一个步骤，所以效率也不高。

适用于老年代这种GC频率低的场景

### 垃圾收集器

JDK默认垃圾收集器：

1.8：Parallel Scavenge（新生代）+Parallel Old（老年代）

1.9 - 20：G1

![image](https://pdai.tech/images/pics/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg)

#### Serial收集器

Serial顾名思义为串行串行的垃圾回收器，历史最悠久。回收的时候会暂停其他所有的工作线程（STW）。

新生代采用标记复制算法，老年代采用标记整理算法。

线程切换的性能消耗很小，可以获得很高的单线程回收效率。但缺点是会让程序暂停的时间比较久。适用于client端。

![ParNew 收集器 ](https://camo.githubusercontent.com/5c0f22abb1605a2b64f2a23efe87b03859d62b36f7eec326ab0b7e47a66c6519/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f7061726e65772d676172626167652d636f6c6c6563746f722e706e67)

#### ParNew收集器

Serial的多线程版，除了使用多线程收集垃圾，其他行为（控制参数，收集算法，回收策略）完全和Serial一样

新生代使用标记复制算法，老年代使用标记整理算法

Server模式下的首选，因为除了Serial外，只有它能和CMS配合使用

![ParNew 收集器 ](https://camo.githubusercontent.com/5c0f22abb1605a2b64f2a23efe87b03859d62b36f7eec326ab0b7e47a66c6519/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f7061726e65772d676172626167652d636f6c6c6563746f722e706e67)

注意：

**并发（Concurrent）**：垃圾线程与用户线程同时执行。

**并行（Parallel）**：多条垃圾回收线程同时执行，此时STW



#### Parallel Scavenge收集器

也是使用标记复制算法的多线程收集器。又被称为“吞吐量优先”收集器，因为其与ParNew的区别在与其关注的是用户线程的卡顿时间。能通过配置优化用户线程的停顿时间。

因为手工优化是比较困难的，所以使用Parallel Scavenge配合自适应调节策略，可以轻松达到合理的配置。但代价是，新生代的空间变小，垃圾回收变得频繁。

新生代使用标记复制算法，老年代使用标记整理算法。

![Parallel Old收集器运行示意图](https://camo.githubusercontent.com/4b1224e3d2bdaccf91e9797586d1aa5da8f1e59660909bf32e1e8e9ac39f781c/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f706172616c6c656c2d73636176656e67652d676172626167652d636f6c6c6563746f722e706e67)

#### Serial Old收集器

Serial收集器的老年版本。同样是单线程收集器，主要有两大用途：

1. 在1.5以前的版本中与Parallel Scavenge搭配使用
2. 作为CMS中Concurrent Mode Failure时的后备方案

![Serial 收集器](https://camo.githubusercontent.com/f8c4e526e3c11ac029ae224d1eef3d87726e2e365a487f933191ba780d263192/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f73657269616c2d676172626167652d636f6c6c6563746f722e706e67)

#### Parellel Old收集器

Parellel Scavenge的老年版本。使用标记整理算法。在注重吞吐量和CPU资源的情况下都可以优先考虑Parellel Scavenge + Parellel Old

![Parallel Old收集器运行示意图](https://camo.githubusercontent.com/4b1224e3d2bdaccf91e9797586d1aa5da8f1e59660909bf32e1e8e9ac39f781c/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f706172616c6c656c2d73636176656e67652d676172626167652d636f6c6c6563746f722e706e67)

#### CMS收集器

CMS是一种注重获取最短停顿的收集器，注重用户体验。同时也是HotSpot上第一款真正意义上的并发收集器。第一次实现了垃圾收集线程与用户线程同时工作。

全名为Concurrent Mark Sweep，可以看出使用的是标记清除算法。

工作分为以下四个步骤：

**初始标记**：STW并且标记直接与root相关的对象。由于范围对象小，所以速度很快。

**并发标记**：开启一个GC线程同时与用户线程工作，GC会沿着初始标记的引用链标记可达对象。但由于是并发的，所以不能保证可达性分析的实时性。

**重新标记**：STW并使用多个线程重新修正上一步骤中产生变动的对象的标记。

**并发清除**：开启GC线程并发清理未被标记的对象

CMS的特点是，并发收集，低停顿。

但是有以下缺点：

无法处理浮动垃圾

对cpu资源敏感

使用标记清除会产生大量的内存碎片

![CMS 收集器](https://camo.githubusercontent.com/c308810c393a1436108401d3085a8c443a099dcdb884af1a508f08e3b0a07b97/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f636d732d676172626167652d636f6c6c6563746f722e706e67)

#### G1回收器

![image](https://pdai.tech/images/pics/9bbddeeb-e939-41f0-8e8e-2b1a0aa7e0a7.png)

Garbage-First，面向服务器的垃圾收集器。同时兼顾了高吞吐量和低停顿。

G1与传统垃圾收集器不同，他把堆划分成大小相等的区（Region），每个区域根据属性可以分为新生代，老年代和永久代。每次的收集单位以区进行，使得它可以同时对新生代和老年代同时回收。区的引入使得预测停顿时间成为可能。内部会维护一个优先列表，根据收集的时间，优先回收效益最大的区域。

同时内部还维护一个Remembered Set记录对象所在的区。这样使用可达性分析的时候可以避免全表扫描。

从整体上来看，其基于标记整理算法，从局部来看其基于复制算法（两个Region），避免产生大量内存碎片。

![CMS 收集器](https://camo.githubusercontent.com/c308810c393a1436108401d3085a8c443a099dcdb884af1a508f08e3b0a07b97/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f636d732d676172626167652d636f6c6c6563746f722e706e67)

## 类的加载

当我们需要初始化一个对象，该对象所属的类必须加载到了方法区。

类的加载可以分为五个步骤：**加载**，**验证**，**准备**，**解析**和**初始化**。

而验证，准备和初始化又可以合并成为**连接**

类的加载会被以下几个步骤触发：

1. 使用new创建该类的对象，或者访问该类的静态方法或字段
2. 使用反射获取类
3. 当子类被加载的时候。因为如果父类没有被加载会先加载父类
4. 使用轻量级反射调用如MethodHandle

![一个类的完整生命周期](https://camo.githubusercontent.com/96339457824a4ae70591f625e274f961cc1c5a37b615ecabd4a653af5c52fbe3/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f6c6966656379636c652d6f662d612d636c6173732e706e67)

### 加载

加载在JVM中的定义为“**通过全类名获取类的二进制流**，而对于怎么获取，JVM规范并没有定义，所以这一步是可控性最强的阶段，可以自定义多种方式。一般自定义加载类的步骤就是在这一步进行修改。

比如从网络获取，jar包，war包，动态代理等方式。

类的加载动作是通过类的加载器完成的（类的加载器知识在后面）

注意：只有数组不是通过类加载器创建的，而是JVM在需要的时候自动创建的。



### 验证

验证是连接的第一步，目的是**确保加载的二进制流是合法的类文件**，且对JVM没有危害。比如验证class文件头cafebabe，元数据验证，字节码验证，符号引用验证等。

这一步所消耗的资源比较多，但安全性可以得到保证。但在真实的生产环境中，所有的文件都反复得到过验证，不需要这一步，所以可以通过设置 `-Xverify:none`取消这一步。



### 准备

准备阶段会生成类的静态变量，即**创建类中被static修饰的变量**，同时赋零值，但如果变量被final修饰，此时就会为类赋初始值。



### 解析

此步骤将常量池内的**符号引用**替换为**直接引用**。主要针对类或接口，方法，字段等的符号引用进行。

比如在其他对象调用该类的方法时，系统需要知道该方法中的内存地址。而运行时常量池中会为每个类维护一个放发表，存有该类的方法的偏移地址，即可马上找到对应的方法。在解析前编译后，运行时常量池所存的不过是该方法的符号引用。



### 初始化

初始化会执行类的初始化方法<clinit>,该方法会执行static类初始化代码块。到这一步JVM层面的类初始化才算结束，而代码层面的初始化才开始。



### 双亲委派机制

#### 类的加载器

类的加载中，如果一个类对应有多个实现，JVM应该如何选择？类加载器中的双亲委派机制就是为了解决这个问题。

类的加载是为了把class文件加载到JVM中并生成class对象。双亲委派机制是JVM的一种安全机制，保护核心的类不被破坏并且。

首先了解下类的加载器，从高到低一共有四种：BootstrapClassLoader，ExtensionClassLoader，AppClassLoader和CustomClassLoader

**BootstrapClassLoader**：用于加载就avahome下的lib中定义的类。即所有的java核心类都由它加载。可以避免核心类被破坏。

比如如果有人重写了Java.lang.String类，系统也不会受到破坏，因为String类加载时会先加载javahome中定义的，保证了系统的安全

**ExtensionClassLoader**：用于加载lib下ext的类以及被java.ext.dirs指定目录下的类。

**AppClassLoader**：加载用户程序定义的类以及所有的第三方引用依赖的类。

**CustomClassLoader**：除了上述的加载器，我们可以自定义类的加载器以满足我们的特殊需求。如果需要自定义类加载器，只需要继承ClassLoader并且重写findClass方法。如果需要打破双亲委派规则则需要重写loadClass方法。因为双亲委派规则的逻辑是写在loadClass方法中。



#### 双亲委派机制

双亲委派机制具体如下：

当一个加载器需要加载某一个类的时候，它自身并不会先去加载，而是先让其父加载器去加载，如果父类成功加载则直接返回，否则再自己尝试加载。如果自己加载失败，则会抛出ClassNotFoundException。

注意：

由于最顶层的BootstrapClassLoader是由c++写的，所有ExtensionClassLoader调用父类加载器会显示为null

两个类相等必须满足其加载器也相等



#### 打破双亲委派机制

![Tomcat 的类加载器的层次结构](https://camo.githubusercontent.com/db911ce361c462fc603128665bef31fd34854f4729314ed5bd4ffbba72744b63/68747470733a2f2f6f73732e6a61766167756964652e636e2f6769746875622f6a61766167756964652f6a6176612f6a766d2f746f6d6361742d636c6173732d6c6f616465722d706172656e74732d64656c65676174696f6e2d6d6f64656c2e706e67)

如果需要打破双亲委派机制，则需要重写loadClass方法。一般来讲不会有这种需求。少数情况，如tomcat就打破了双亲委派机制。

tomcat需要能优先加载Web应用目录下的类，再加载其他应用的类从而实现不同Web应用之间的依赖隔离和共享。

具体如下，自定义类加载器会存放该版本tomcat中的公共依赖。实现公共类的共享。

CatalinaClassLoader用于加载Tomcat自身所需的依赖，以隔离服务器和应用的依赖。

SharedClassLoader用于加载不同Web应用的共享依赖，比如多个Web应用使用相同版本的Spring，那么Spring应该放在这里。

WebAppClassLoader用于加载Web应用自身独显的依赖，实现Web应用的依赖隔离



#### 逆向加载

JVM规定了父子加载器都需要同一个类加载器加载，但有些情况下，父加载器需要调用子加载器才能实现类的加载，此时如果按照双亲委派机制是找不到类的。比如java核心类库定义了java.sql.Driver接口，而接口的具体实现由Mysql提供，即需要被CustomClassLoader加载。这种情况下，可以使用线程上下文加载器达到“在同一线程传播子类实现的加载器”的目的。即高层的类加载器需要调用子类加载器去加载类。